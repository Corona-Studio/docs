# Система аутентификации Microsoft

[[toc]]

Эта системы аутентификации реализует новый процесс аутентификации на основе Azure, который применим ко всем версиям Minecraft, которые в настоящее время обслуживаются.

## Подготовка

Поскольку новый процесс аутентификации использует метод аутентификации на основе Azure.
Поэтому, прежде чем начать, убедитесь, что вы завершили [конфигурацию приложения Azure](/ruRU/projbobcat/createNewAzureApp).

После завершения регистрации приложения Azure убедитесь, что вы завершили [инициализацию аутентификатора Microsoft](/ruRU/projbobcat/installationAndConfig.md#настройка-аутентификатора-входа-в-microsoft) в точке входа программы.

### Настройка метода предоставления кэшированных учетных данных

Из-за особенностей этой системи аутентификации разработчикам необходимо сохранять **токен обновления** и **время истечения срока действия**, возвращаемые при первой аутентификации, чтобы помочь аутентификатору завершить аутентификацию.
При аутентификации аутентификатор сначала вызовет этот метод, чтобы проверить действительность локального кэша токенов. Если локальный токен все еще действителен, результат аутентификации будет возвращен напрямую.
Если токен, кэшированный локально, истек, разработчику необходимо вручную запросить новый токен, а затем вернуть обновленный токен.

Ниже мы приводим пример реализации этого метода:

```c#
public async Task<(bool, GraphAuthResultModel?)> CacheTokenProviderAsync()
{
    if (string.IsNullOrEmpty(XBLToken)) return (false,  default);
    if (string.IsNullOrEmpty(XBLRefreshToken)) return (false,  default);

    // Рассчитать время истечения срока действия // [!code focus]
    var expireDate = LastRefreshedTime.AddSeconds(ExpiresIn); // [!code focus]

    // Если локальный кэшированный токен все еще действителен, вернуть текущий токен напрямую // [!code focus]
    // В противном случае используйте токен обновления для запроса нового токена // [!code focus]
    if (expireDate > DateTime.Now)
    {
        var result = new GraphAuthResultModel // [!code focus]
        { // [!code focus]
            ExpiresIn = (int)(expireDate - DateTime.Now).TotalSeconds,  // [!code focus]
            AccessToken = XBLToken,  // [!code focus]
            RefreshToken = XBLRefreshToken // [!code focus]
        }; // [!code focus]

        return (true,  result); // [!code focus]
    }
    
    // Запросить новый токен входа // [!code focus]
    var refreshReqDic = new List<KeyValuePair<string,  string>> // [!code focus]
    { // [!code focus]
        new("client_id",  MicrosoftAuthenticator.ApiSettings.ClientId),  // [!code focus]
        new("refresh_token",  XBLRefreshToken),  // [!code focus]
        new("grant_type",  "refresh_token") // [!code focus]
    }; // [!code focus]

    using var refreshReq = new HttpRequestMessage(HttpMethod.Post,  MicrosoftAuthenticator.MSRefreshTokenRequestUrl) // [!code focus]
    { // [!code focus]
        Content = new FormUrlEncodedContent(refreshReqDic) // [!code focus]
    }; // [!code focus]

    using var refreshRes = await DefaultClient.SendAsync(refreshReq);
    var refreshContent = await refreshRes.Content.ReadAsStringAsync();
    var refreshModel = MicrosoftAuthenticator.ResolveMSGraphResult(refreshContent,
    GraphAuthResultModelContext.Default.GraphAuthResultModel);

    if (refreshModel is not GraphAuthResultModel model)
    {
        if (refreshModel is GraphResponseErrorModel error) // [!code focus]
        { // [!code focus]
            // Обработка неудачной операции обновления здесь // [!code focus]
        } // [!code focus]

        return (false,  default);
    }

    return (true,  model);
}
```

###  Настройка метода отображения кода аутентификации потока устройства при первом входе

Поскольку мы используем аутентификацию потока устройства для аутентификации учетной записи Microsoft игрока.
Поэтому нам нужен дополнительный метод для отображения пользователю одноразового ключа и адреса аутентификации, необходимых для аутентификации потока устройства.

Ниже приведен пример этого метода:

```c#
private void DeviceTokenNotifier(DeviceIdResponseModel deviceIdResponseModel)
{
    // Отображение полученных данных обратного вызова на внешнем интерфейсе
    DeviceCodeResponse = deviceIdResponseModel;
}
```

**DeviceIdResponseModel** содержит всю информацию, необходимую пользователю для завершения аутентификации:

|       Название        |           Действие            |
|:---------------:|:-----------------------:|
|    UserCode     |       Ключ, необходимый для аутентификации пользователя        |
| VerificationUri | Адрес аутентификации, который пользователи должны посетить для выполнения последующих шагов аутентификации |
|    ExpiresIn    |      Время истечения срока действия кода аутентификации (секунды)       |

Ниже вы можете увидеть пример интерфейса отображения:

![device_token_demo](/img/projbobcat/authenticators/device_token_auth_display_demo.png)

В этом интерфейсе вам необходимо включить как минимум следующее содержимое:

- Ключ, необходимый для входа
- Конкретный адрес аутентификации
- Краткая подсказка по работе, чтобы помочь пользователям завершить операцию аутентификации

## Инициализация аутентификатора

### Первая аутентификация

:::warning

Убедитесь, что вы подготовили **метод отображения кода аутентификации потока устройства при первом входе** перед выполнением следующего процесса, чтобы убедиться, что пользователи могут получить правильную информацию для первого входа!

:::

Инициализация аутентификатора:

```c#
var microsoftAuthenticator = new MicrosoftAuthenticator
{
    LauncherAccountParser = launcherAccountParser
};
```

В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией:

|          Элемент           |                             Описание                              |
|:---------------------:|:-----------------------------------------------------------:|
| launcherAccountParser |                     Для инициализации парсера учетных записей лаунчера см. здесь                     |

### Не первая аутентификация

Не первая аутентификация — это использование кэша токенов, полученного при первой аутентификации, для вторичной аутентификации.
В основном он проверяет, действительны ли локальные учетные данные через CacheTokenProviderAsync. Если токен, кэшированный локально, истек, он будет обновлен в этом методе.

Инициализация аутентификатора:

```c#
var microsoftAuthenticator = new MicrosoftAuthenticator
{
    CacheTokenProvider = CacheTokenProviderAsync,
    Email = "[EMAIL]",
    LauncherAccountParser = launcherAccountParser
};
```

В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией:

|          Элемент           |                             Описание                              |
|:---------------------:|:-----------------------------------------------------------:|
| launcherAccountParser |                     Для инициализации парсера учетных записей лаунчера см. здесь                     |
|        [EMAIL]        |                          Адрес электронной почты учетной записи аутентификации                          |

:::tip

Для инициализации **launcherAccountParser** (парсера игровых профилей) см. страницу [Парсер игровых профилей](/ruRU/projbobcat/additionalParsers/gameProfileParser).

:::

## Получение результата аутентификации (первая аутентификация)

После завершения инициализации системи аутентификации вам нужно только вызвать метод аутентификации аутентификатора Microsoft для первоначальной аутентификации учетной записи.

Ниже приведен пример кода аутентификации:

```c#
// Получить результат аутентификации // [!code focus]
// DeviceTokenNotifier — это метод отображения информации, упомянутый ранее // [!code focus]
var authResult = await msAuth.GetMSAuthResult(DeviceTokenNotifier); // [!code focus]

if (authResult == null)
{
    // Обработка неудачной аутентификации // [!code focus]
}

// Разбор полей пользователя из токена Jwt // [!code focus]
var claims = JwtTokenHelper.GetTokenInfo(authResult.IdToken); // [!code focus]
var email = claims.TryGetValue("email", out var outEmail) ? outEmail : null; // [!code focus]

if (string.IsNullOrEmpty(email))
{
    // Невозможно разобрать адрес электронной почты пользователя из учетных данных Jwt, рассматривается как сбой аутентификации // [!code focus]
    // Это, скорее всего, вызвано сбоем конфигурации приложения Azure или Scope // [!code focus]
}

// Сохранение необходимой информации о пользователе на локальный диск для подготовки к следующей аутентификации // [!code focus]
var msInfoModel = new MSAccountInfoModel
{
    XBLToken = authResult.AccessToken, // [!code focus]
    XBLRefreshToken = authResult.RefreshToken, // [!code focus]
    ExpiresIn = authResult.ExpiresIn, // [!code focus]
    Email = email // [!code focus]
};
```

## Получение результата аутентификации (не первая аутентификация)

После завершения инициализации системи аутентификации вам нужно только вызвать метод аутентификации аутентификатора Microsoft для завершения аутентификации учетной записи.

В асинхронном контексте используйте **AuthTaskAsync** для завершения аутентификации:

```c#
var authResult = await microsoftAuthenticator.AuthTaskAsync(false);
```

В синхронном контексте используйте **Auth** для завершения аутентификации:

```c#
var authResult = microsoftAuthenticator.Auth();
```

## Интерпретация результата аутентификации

После завершения метода аутентификации оно вернет результат аутентификации, который является объектом родительского типа [AuthResultBase](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/Auth/AuthResultBase.cs).
Все результаты аутентификации содержат значение перечисления **AuthStatus**, которое напрямую указывает на успех или неудачу аутентификации.
Ниже вы можете увидеть интерпретацию результата аутентификации:

### Неудачный результат аутентификации

Определив, является ли **Error** пустым, вы можете легко определить, является ли результат аутентификации, возвращенный системой аутентификации, действительным.
Объект **Error** будет содержать следующие поля, чтобы сообщить вам некоторые подробности:

|              Поле               |        Описание        |
|:-----------------------------:|:----------------:|
|    authResult.Error.Cause     |    Конкретная причина проблемы     |
|    authResult.Error.Error     |       Название ошибки       |
| authResult.Error.ErrorMessage | Подробная информация об ошибке, может содержать решение |

### Успешный результат аутентификации

Если поле **Error** в результате аутентификации пусто, это означает, что эта аутентификация действительна. Успешный результат аутентификации будет содержать следующую информацию:

|               Поле               |                     Описание                      |
|:------------------------------:|:-------------------------------------------:|
|         authResult.Id          |   Уникальный идентификатор этого имени пользователя, ProjBobcat использует определенный метод генерации для генерации этого идентификатора   |
|     authResult.AccessToken     |                  Учетные данные авторизации учетной записи пользователя                  |
|      authResult.Profiles       |            Список доступных ролей для пользователя, может содержать несколько доступных ролей             |
|   authResult.SelectedProfile   |    Текущая выбранная роль пользователя, это поле может быть пустым. Если оно пустое, пользователю необходимо предложить выбрать вручную.     |
|        authResult.User         |            Сводка информации об учетной записи пользователя, содержит некоторую основную информацию об учетной записи             |
|       authResult.LocalId       |             Локальный ID, обычно случайно сгенерированный UUID             |
|      authResult.RemoteId       |         Удаленный ID, возвращенный сервером аутентификации, обычно уникальный идентификатор пользователя          |
|       authResult.XBoxUid       |                XBox Live UID                |
|        authResult.Email        |                 Адрес электронной почты, используемый для аутентификации                  |
|   authResult.CurrentAuthTime   |   Текущее время аутентификации, **разработчикам необходимо сохранить это поле, чтобы помочь подтвердить действительность локального кэшированного токена**    |
|      authResult.ExpiresIn      | Время истечения срока действия токена (единица измерения: секунды), **разработчикам необходимо сохранить это поле, чтобы помочь подтвердить действительность локального кэшированного токена** |
|    authResult.RefreshToken     |       Токен обновления, **разработчикам необходимо сохранить это поле, чтобы помочь обновить просроченные токены**        |
|        authResult.Skin         |                 URL-адрес скина учетной записи пользователя                 |

:::warning

Пожалуйста, используйте соответствующие ограничения или шифрование для безопасного хранения конфиденциальных данных, связанных с токенами пользователей. Утечка этой части данных может привести к потерям.

:::
